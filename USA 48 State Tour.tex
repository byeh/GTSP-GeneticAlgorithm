\documentclass[12pt]{article}
\usepackage{fullpage,url,amssymb,epsfig,color,xspace,amsmath}
\usepackage{graphicx}
\usepackage[margin=1in]{geometry}
\setlength\parindent{0pt}
\setlength{\parindent}{0pt}
\usepackage{setspace}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric}
\usepackage{verbatim}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{array}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{mathrsfs}
\usepackage{enumitem}
\usepackage{tcolorbox}
\setlist{noitemsep}
\usetikzlibrary{arrows,shapes}
\usepackage{hyperref}
\usetikzlibrary{calc}

% New column types that allow text wrap, fixed width columns and alignments
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

% Creates a 2 column setup for definitions, notes and theorems so that
% the note text can wrap and be nicely aligned
\newcommand{\Definition}[1] {\categoryhelper{Definition}{#1}{1in}{5.5in}}
\newcommand{\Lemma}[1] {\categoryhelper{Lemma}{#1}{1in}{5.5in}}
\newcommand{\Note}[1] {\categoryhelper{Note:}{#1}{0.5in}{6in}}
\newcommand{\Theorem}[1] {\categoryhelper{Theorem}{#1}{1in}{5.5in}}
\newcommand{\TheoremName}[4]{\categoryhelper{#1}{#2}{#3}{#4}}
\newcommand{\Problem}[1]{\categoryhelper{Problem}{#1}{1in}{5.5in}}
% Helper method that takes in the width of the two columns as well 
% as the title and description
\newcommand{\categoryhelper}[4]
  {
    \begin{tabular*}{\linewidth}{@{} L{#3} @{\extracolsep{\fill}} p{#4}@{}}
    \textbf{#1} & #2
    \end{tabular*}
  }
\newcommand{\Question}{\paragraph{Question}}
\newcommand{\Example}{\paragraph{Example}}
\newcommand{\tabfour}{\hspace*{100pt}}
\newcommand{\tabthree}{\hspace*{75pt}}
\newcommand{\tabtwo}{\hspace*{50pt}}
\newcommand{\tab}{\hspace*{25pt}}
\newcommand{\ra}{\rightarrow}
\newcommand{\Ra}{\Rightarrow}
\newcommand{\la}{\leftarrow}
\hypersetup{
    colorlinks=true, %set true if you want colored links
    linktoc=all,     %set to all if you want both sections and subsections linked
    linkcolor=blue,  %choose some color if you want links to stand out
    }

\begin{document}
\begin{center}
\vspace*{6cm}
\textbf{\LARGE The Generalized Travelling Salesman Problem}\\
\Large Finding the shortest possible USA 49 States Tour\\

\large CO353 - Final Project
\large Brandon Yeh\\
\end{center}

\newpage

\section{Overview}

In the Generalized Travelling Salesman Problem (GTSP), the nodes $V$ are partitioned into $k$ clusters $V_1,V_2,...,V_k$ and the goal is to find a minimum cost circuit that includes exactly one node in each cluster.\\

In this report, a well known genetic algorithm published by John Silberholz and Bruce L. Golden is used to attempt to find a good solution to the 49 tour problem. \url{http://josilber.scripts.mit.edu/GTSP.pdf}.\\

However, this genetic algorithm only tests instances with up to 1000 nodes and a large number of clusters with approximately 5 nodes each. There is no computational data provided to show the performance of such an algorithm with siginificantly greater nodes and few smaller clusters. More specifically, this report will outline the performance of such an algorithm that contains 49 clusters of, on average, 2300 nodes each and 115475 nodes in total.

\subsection{Technologies Used}

A script was created and used to convert the lines in \verb|usa115475_cities.txt| to ensure consistent tokenization of each x coordinate, y coordinate, city, county and state per line.\\

Implementation of this algorithm is done in Java 8 Version 74, using only the native libraries provided in the SDK. The computer used to run the computational tests have the following properties:
\begin{enumerate}
  \item Acer Aspire 5755G-9417 with an Intel Core i7-2670QM 2.2GHz Processor
  \item Operating System: Ubuntu 14.04.4 LTS running Linux Kernel 3.13.0-83-generic (i686)
  \item 2x Crucial 4GB Single DDR3 1600 MT/s PC3-12800 CL11 SODIMM 204-Pin 1.35V/1.5V Notebook Memory CT51264BF160BJ 
  \item Samsung Electronics 840 EVO-Series 250GB 2.5-Inch SATA III Single Unit Version Internal Solid State Drive MZ-7TE250BW 
\end{enumerate}

Finally, Google's Static Maps API is used to visualize the tour across the continental United States.

\section{Problem Formulation}

This section of the report will formally define the problem that the modified genetic algorithm will solve.\\

The following data is to be used as input to the genetic algorithm:
\begin{enumerate}
  \item A list of 49 States in the continental USA
  \item A list of 115475 cities in the above 49 states provided from the following url:\\ \url{http://www.math.uwaterloo.ca/tsp/data/usa/usa115475_cities.txt}
\end{enumerate}

Furthermore, the following assumptions are made to simplify the problem:
\begin{enumerate}
  \item The travel distance between 2 cities provided in the list of cities above is the Euclidean distance between the pair of cities. This identical to the EUC\_2D method in TSPLIB.
\end{enumerate}

Finally, the problem is defined formally:
\begin{tcolorbox}
  Given a list of 49 states in the continental USA and a list of cities within each state, find the shortest tour through each 49 states, visiting exactly one city in each state.
\end{tcolorbox}

\section{The Genetic Algorithm}

As noted in the overview, the algorithm used to sove this 49 State USA tour is inspired by John Silberholz and Bruce L. Golden albiet, with a few modifications. 

\subsection{Input Parameters}
  The following input parameters are defined in the algorithm itself:
  \begin{verbatim}
    private int INITIAL_POPULATION_SIZE;
    private int NUMBER_OF_ISOLATED_POPULATIONS;
    private int TOTAL_GENERATIONS;
    private int REPLICATON_SIZE;
    private int REPRODUCTION_SIZE;
    private int TERMINATION_CONDITION;
  \end{verbatim}

We first define the size of each isolated population as well as the number of isolated populations. Furthermore, for each replication and reproduction phase, we define how many tours are replicated and how many tours are generated by mating. Finally, we define how many generations the isolated population will evolve as well as a cutoff point for the replication and reproduction of the merged population.

\subsection{Data Structures}

In this algorithm, the following data structures are used to minimize the computational impact on processing the algorithm.\\

We define a \textit{City} class as follows with the following instance variables
\begin{verbatim}
  private Location coord;
  private String city;
  private String county;
  private String state;
\end{verbatim}

Where \textit{Location} contains the $x,y$ coordinates of the city and the other fields contain the city, county and state. Furthermore, an API is provided for this class to access and modify fields.\\

To easily access cities within a given state, a \textit{HashMap} is used. Specifically, the code used is: \verb|HashMap <String, ArrayList<City>> states;|. As part of the mrOX requires an iteration through all cities within a state, this setup provides constant time lookup to get information on all the cities in a state and then linear time to iterate through all the cities.\\


We finally define a \textit{Tour} class as follows with the following instance variables:
\begin{verbatim}
  private ArrayList <City> tour;
  private int tourSize;
  private double tourLength;
  private int maxSize;
\end{verbatim}

The main reasoning to use an \textit{ArrayList} for a tour is that each pairwise adjacent city can be defined has having an edge between them. Then the order of cities in the \textit{ArrayList} is the order of cities that the tour goes through. This allows the algorithm to compute the tour length in linear time, report the tour city by city in linear time and also easily replace any city in a tour with another city.


\subsection{Isolated Population Generation}

The algorithm begins with an initial set of isolated populations, generated randomly then optimized with the 2-opt algorithm. The algorithm will generate multiple sets of populations based on the \verb|NUMBER_OF_ISOLATED_POPULATIONS| parameter, each with a population size of \verb|INITIAL_POPULATION_SIZE|. 

\subsection{Natural Selection}

The natural selection subroutine for this algorithm is inspired by the simple concept of natural selection. Given each isolated population's population size, we consistently segment this population into two groups. One group of tours that are destined to move on to the next generation and the other group destined to die off. We order the tours within the population in ascending order and select the best $n$ tours, defined by \verb|REPLICATION_SIZE| for replication and the remaining tours for disposal. 

\subsection{Reproduction}

Reproduction of new tours is inspired by the Ordered Crossover technique implemented by the paper. The algorithm will select two random tours that were assigned for replication, and run the Rotational Ordered Crossover algorithm (rOX). The resulting child is then added to the population. 

\subsection{Population Merging}

Once each isolated population has been processed through a set number of generations as defined by \verb|TOTAL_GENERATIONS|. The final step is to merge all the isolated populations together into one large population and then repeat the natural selection and reproduction process again. However some differences in the subroutines are present in each cycle compared to a cycle in an isolated population.\\

In the natural selection subroutine, as we are selecting the top $n$ tours defined as \verb|REPLICATION|
\verb|_SIZE| * \verb|NUMEBR_OF_ISOLATED_TOURS|. However, there may be cases where two or more tours have the same tour length. In this case, if there exists more than one tour with the same tour length in the replication group, we discard all but the first tour found.\\

In the reproduction subroutine, child tours are also generated using the Ordered Crossover technique, however the more computationally intensive modified rotational ordered crossover technique (mROX). Finally, the best tour returned by the mrOX heuristic is then run through a 2-opt local improvement heuristic, further improving the tour length. 

\subsection{Termination} 

Once the merged population begins to interate through generations, there may be a point where the tour set will converge on a single solution, or it takes a painstakingly long time to minimally improve the best solution found so far. To take care of these issues, a \verb|TERMINATION_CONDITION| parameter is added to force the algorithm to terminate after a set number of iterations.\\

However, there may be cases where there does exist better solutions in the solution space and to ensure that the termination isn't done forcefully, an additional constraint on termination was added to allow a new generation of tours that may only occur after a few generation. The algorithm will then terminate when the \verb|TERMINATION_CONDITION| is reach and if the best tour is stagnated for over 10 generations. This allows the algorithm to terminate once there is very mimimal possibility for significant progress.

This also creates a metric which may be interesting to observe and that is defined as \textit{Generation Stagnancy}. That is, how many generations have passed without an improvement to the best solution. The largest number of stagnant generations may be interesting to observe as if a large percentage of the generations have not produced a better solution, it may be better to terminate the merging and take the best one found to date.

\section{Heuristics and Subroutines}

\subsection{Importing Data}

After the provided data has been parsed and modified for ease of tokenization, a linear time algorithm is used to import the data for use. 

\subsection{Random Tour Generation}

Random tour generation, as its namesake, is a strictly psuedo random way to generate a tour. For each state, we randomly select a city and append it to the end of the tour. Furthermore, we generate a random permutation of the states so that the order in which the states are traversed is random.

\subsection{Two Opt Heuristic}

The 2-opt heuristic implemented in this algorithm is a traditional implementation. Simply put, the algorithm will find two edges that cross over, and uncross them to improve the tour. This heuristic will continue searching for all pairs of edges to uncross until there are no more edges that cross each other.
\subsection{Ordered Crossover}

The Ordered Crossover(OX) reproduction heuristic is implemented as outlined in the paper. Furthermore, rotational Ordered Crossover was implement albiet without the reversal of strings operation and modified rotational Ordered Crossover was implemented as well. Although mrOX is computationally expensive, linear time traversal through the cluster was done to maximize efficiency. 

\subsection{Output Data, Reporting and Metrics}

To facilitate data recording and analytics, several data points within each iteration of the algorithm are printed to \textit{stdout} as well as stored in log files. Types of data reported include:
\begin{enumerate}
  \item Current iteration of algorithm
  \item Best Tour Length found so far
  \item Elapsed time at end of iteration of algorithm
  \item Current tour generation stagnation values
\end{enumerate}

Some additional processing of these log files can be done to further analyze the performance of this algorithm. Although these types of analytics are outside the scope of this report and are not tested, some metrics that may prove to be interesting include:
\begin{enumerate}
  \item Average improvement rate of tours per generation
  \item Number of stagnant generations within a testing instance
  \item Ratio of stagnent generations vs improved generations
\end{enumerate}

Metrics like these can be used to analyze the performance of the algorithm and help determine whether there are better input parameters that can be used to further improve the performance of the algorithm. Additionally, these metrics may also provide insight on whether there may be opportunities to use a different algorithm to further improve tour length when it seems that this algorithm is convergining on some value and minimal progess is being made.\\

\section{Testing}

Computational tests were done by varying the values of each individual input parameter. The goal is to determine whether a specific input paramter would significantly improve tour length generation. Additionally, three types of tests were done to compute the best tour available. The two type of tours are as follows:
\begin{enumerate}
  \item Control Computation Instances\\

  Theses computational tests begin strictly with the input parameters and are run until completion. Then appropriate values in the tour are recorded.\\

  \item Importing Best Control Tours Instances\\

  These computational tests allow the option to import any tour that was outputted as a result of running a Control Computation Instance. In order to prevent any errors propagating, these tours are calculated and recorded separately, noting which tours were imported as well as the results of the best tour generated.

\end{enumerate}

The main reasons to segment these computational tests is to determine how effective the algorithm will be in finding a better tour, given the best tours already computed. Furthermore, to ensure that results are not polluted, the recording of the tours that allow imports are separated so as to not influence the results of a completely random instance of the algorithm.

\subsection{Summary}

Testing of various isolated population sizes have shown that very large isolated population sizes may not necessarily produce significantly better results. As each generation takes significantly longer, and as the solution coverges, there must exist a lot of wasteful computation.\\

The best solution found without importing any predefined tours had the following parameters:
\begin{verbatim}
  private int INITIAL_POPULATION_SIZE = 100;
  private int NUMBER_OF_ISOLATED_POPULATIONS = 10;
  private int TOTAL_GENERATIONS = 25;
  private int REPLICATON_SIZE = 0.4 * INITIAL_POPULATION_SIZE;
  private int REPRODUCTION_SIZE = 0.6 * INITIAL_POPULATION_SIZE;
  private int TERMINATION_CONDITION = 150;
\end{verbatim}
With a tour length = 109427.\\

The top 5 results contain four tests that have the following above parameters. Furthermore, the generation stagnancy parameter for termination condition seems to be proving useful as several of these tours either run for over 250 generations to terminating at 150. So it is clear that depending on the random generation/modification components of the tour, the solution space may either quickly converge or extrememly slowly converge on the best tour. It seems that the generation stagnancy is effective in drawing out the potential in a population.\\

The best solution while importing the best control tours has the following parameters:
\begin{verbatim}
  private int INITIAL_POPULATION_SIZE = 50;
  private int NUMBER_OF_ISOLATED_POPULATIONS = 5;
  private int TOTAL_GENERATIONS = 25;
  private int REPLICATON_SIZE = 0.4 * INITIAL_POPULATION_SIZE;
  private int REPRODUCTION_SIZE = 0.6 * INITIAL_POPULATION_SIZE;
  private int TERMINATION_CONDITION = 150;
\end{verbatim}

The best tour length found so far using this method has length 109380.\\

The computational tests for these types of instances are very interesting as the best imported solutions tend to dominate all other solutions. Furthermore, the max stagnant generations values go up significantly and very early in the algorithm. It seems that using existing tours will significantly skew the solution set, and having 71 stagnant generations in a row in 150 iterations shows that the algorithm is not generating any better solutions at a good probability. Therefore, these tests can validate that the control tours generated are of near optimal length.\\

The full results can be found in the spreadsheet, \textit{results.xlsx}, provided with this report.
\end{document}